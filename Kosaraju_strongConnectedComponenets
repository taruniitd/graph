#include <iostream>
#include <bits/stdc++.h>
using namespace std;

class DirectedGraph
{
    int numVertex;
    
    list<int> *adjList;
    
    bool *visited;
    
    stack<int> Stack;
    
    public: 
    
    DirectedGraph(int numVertex);
    
    void addEdge(int src, int dest);
    
    void fillOrderInStack(int v);
    
    DirectedGraph gphTranspose();
    
    void DFSUtil(int curVer);
    
    void printStrgConnComp();
};

DirectedGraph :: DirectedGraph(int V)
{
    numVertex = V;
    adjList = new list<int>[numVertex];
    visited = new bool[numVertex];   
}

void DirectedGraph :: addEdge(int src, int dest)
{
    adjList[src].push_back(dest);
}

void DirectedGraph :: fillOrderInStack(int v)
{
    visited[v] = true;
    list<int>::iterator listIter;
    for(listIter = adjList[v].begin(); listIter != adjList[v].end(); ++listIter)
    {
        if(!visited[*listIter])
        {
            cout << "Fill DFS order : " << *listIter << "   ";
            fillOrderInStack(*listIter);
        }
    }
        
    Stack.push(*listIter);
    cout << "Vertex order in stack :" << endl;
    cout << *listIter;
}

DirectedGraph DirectedGraph :: gphTranspose()
{
    DirectedGraph gphTr(numVertex);
    
    for(int ver = 0; ver < numVertex; ver++)
    {
        list<int>::iterator listIter;
        for(listIter = adjList[ver].begin(); listIter != adjList[ver].end(); listIter++)
        {
            gphTr.addEdge(*listIter, ver);
        }
    }
    return gphTr;
    
}

void DirectedGraph :: DFSUtil(int curVer)
{
    visited[curVer] = true;
    
    list<int>::iterator listIter;
    for(listIter = adjList[curVer].begin(); listIter != adjList[curVer].end(); listIter++)
    {
        if(!visited[*listIter])
            DFSUtil(*listIter);
    }
    
    cout << "current strongly conneced Vertex are : " << *listIter << "  ";
}
void DirectedGraph :: printStrgConnComp()
{
    for(int vis = 0; vis < numVertex; vis++)
        visited[vis] = false;
     
    for(int ver = 0; ver < numVertex; ver++)
    {    
        fillOrderInStack(ver);
    }
    
    
    
    DirectedGraph gphTr = gphTranspose( );
    
    for(int ver = 0; ver < numVertex; ver++)
        visited[ver] = false;
    
    while(Stack.empty() == false)
    {
        int curVer = Stack.top();
        Stack.pop();
        
        gphTr.DFSUtil(curVer);
        cout << "next scc group " << endl;
    }
    
}
int main()
{
    DirectedGraph gph(5);
    gph.addEdge(0,2);
    gph.addEdge(0,3);
    gph.addEdge(1,0);
    gph.addEdge(2,1);
    gph.addEdge(3,4);

    gph.printStrgConnComp();
}
